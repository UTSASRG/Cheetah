\section{Discussion}

\label{sec:discuss}

This section addresses some possible concerns related to \Cheetah{}. 

\paragraph{Hardware Dependence.} \cheetah{} is an approach that relies on the hardware PMU unit to sample memory accesses. To use \cheetah{}, users should setup the PMU-based sampling beforehand. After that, they can connect to the library with the detection, prediction, and reporting component by calling only one API. Users should add the initialization of PMU at startup or in the begin of every thread, with adding less than 10 lines of code. Currently, we have implemented the hardware support for the AMD Opteron machine and plan to extend the support to Intel PEBS-related machines. 

\paragraph{Performance Overhead.} On average, \Cheetah{} only introduces 7\% performance overhead for all evaluated applications. However, \cheetah{} does introduce more than 20\% overhead for two applications with a large number of threads because \cheetah{} should setup hardware registers for every thread. Although creating a large number of threads in an application is not normal, we expect to only setup once with better hardware support. We also expect that the overhead can be further reduced by only sampling memory accesses, but not non-related instructions such as arithmetic instructions and logic instructions. Hopefully, the hardware can overcome these two limitations in the future.

\paragraph{Effectiveness.} \Cheetah{} can effectively detect false sharing problems that occur in the current execution and have high impact on the performance. For the effective detection, \Cheetah{} requires programs to run sufficient time, maybe more than few seconds. 
