\label{sec:implement}
This section presents the detailed implementation of \Cheetah{}'s detection: it first describes how to sample memory accesses (in Section~\ref{sec:detect-trace}) and how to compute the number of cache invalidations based on the pattern of memory accesses (see Section~\ref{sec:compute}); then we describes how to report false sharing precisely and correctly (see Section~\ref{sec:report});

%\redmark{Should we add a figure about different components??}

\subsection{Sampling Memory Accesses}
\label{sec:detect-trace}
% How to trace the memory accesses?
% What is the benefit of using performance counter, non-instrusive
% What information that we can get about an memory access
% How we will handle this information? We will pass it to cache invalidations module

As described in Section~\ref{sec:perfcounter}, \Cheetah{} relies on hardware performance counters, such as AMD's IBS registers, to sample memory accesses. Hardware performance counters provide a non-intrusive and efficient approach to track memory accesses. \Cheetah{} is a user library that can be preloaded before the execution of an application. 

Before running an application, \Cheetah{}  registers a signal handler through \texttt{sigaction} so that this signal handler will be called after a specified amount of memory accesses. To improve the performance of handling, \Cheetah{} actually bounds the signal handler to different threads by calling \texttt{fcntl} function so that every thread.  

We intercepts that memory allocations . 
Internally, we are using the thread index as the identifier of tid.  \todo{how to maintain tid or tindex? }
 Inside the signal handler, \Cheetah{} can acquire detailed information on every sampled memory access, including memory address, thread id, read or write operation, and access latency, which will be fed into the computing module to compute the number of cache invalidations and the prediction module to predict performance impact. 


\subsection{Computing Cache Invalidations}
\label{sec:compute}

\Cheetah{} computes possible cache invalidations on each cache line based on the rule that is described in Section~\ref{sec:computeinvalidations}. \Cheetah{} maintains a two-entries-cache-history table for each cache line and checks against the history table to decide whether an access leads to a cache invalidation. In order to locate the cache history of each cache line, \Cheetah{} implements the shadow memory for all virtual addresses, which has been introduced before~\cite{qinzhao}. 

Since \cheetah{} only cares about those cache lines that can potentially involve in false sharing. We observe that only those cache lines with a big number of writes can possibly cause a lot of cache invalidations. Based on this observation, cache lines with a small number of writes are never be a target that can cause serious performance problem. For this reason, \Cheetah{} only tracks those cache lines when the number of writes on a cache line is larger than a pre-defined threshold, which we refer to as the {\it Tracking-Threshold}. Before this threshold is reached, \Cheetah{} only tracks the number of writes on a cache line while skipping tracking reads. This mechanism reduces performance and memory overhead at the same time.

In the implementation, \Cheetah{} maintains two arrays in the shadow memory: {\it CacheWrites} tracks the number of memory writes on every cache line, and {\it CacheTracking} tracks detailed information for each cache line. To save memory, {\it CacheTracking} for a particular cache line is allocated dynamically once the number of writes on this cache line exceeds the {\it Tracking-Threshold}. The history table, number of cache invalidations on a cache line, and detailed memory accesses are actually included in {\it CacheTracking}. These information are going to be checked in the reporting phase that is described in Section~\ref{sec:report}.
 
 \subsection{Reporting False Sharing}
% How we will report false sharing precisely and correctly?
% How we 
\label{sec:report}

\Cheetah{} aims to report false sharing correctly and precisely, same as existing work~\cite{sheriff, Predator}. 

\paragraph{Correct Detection:} \Cheetah{} keeps track of word-based (four bytes) memory accesses on susceptible cache lines: how many reads or writes occurs by which thread on each word. When more than one thread access a word, \Cheetah{} marks this word to be shared. By identifying accesses on each word on a susceptible cache line, we can easily differentiate false sharing from true sharing, as shown in Figure~\ref{fig:falsesharing}. Word-based information can also help diagnose more detailed  condition of false sharing in a particular cache line. Knowing this can help programmer to decide how to padding an existing data structure in order to avoid false sharing.
\todo{ Since it is normal for a thread, particularly the main thread, to allocate an object and do some initialization before passing to different threads, the previous approach may consider this as true sharing but not false sharing. To correctly identify this situation, \cheetah{} only checks memory access inside parallel phase. } 

\paragraph{Precise Detection.} \Cheetah{} reports precise information for global variables and heap objects that are involved in false sharing. For global variables, \Cheetah{} reports names and addresses by searching through the ELF symbol table. For heap objects, \Cheetah{} reports the lines of code for allocating these objects.  
Thus, \Cheetah{} intercepts all memory allocations and de-allocations and utilizes \texttt{backtrace()} to obtain the whole callsite stack.  \Cheetah{} uses its custom memory allocator that are built on Heap Layers~\cite{heaplayers}, which is good for implementing its shadow memory. But this implies that \Cheetah{} can miss false sharings that caused by the memory allocator itself, such as allocating objects for two threads in the same cache line. However, it is not a problem as long as we can use an modern allocator like Hoard~\cite{Hoard}. 

During the real implementation, we tried to keep the overhead of getting the callsite stack as little as possible. \cheetah{} utilizes a global hash table to save those known callsite stack. The combination of ``rip'' (instruction pointer) and ``stack offset'' is considered as the key of this global hash table. If the combination of these two values (as the key) have existed in the global hash table, we simply copied the saved callsite stack to a new object. Otherwise, backtrace() is called to fetch the actual callstack.  

%However, it is straightforward to solve such false sharing problems by using an allocator like Hoard that avoids this kind of false sharing.


%\subsection{Predicting False Sharing}
% What is the basic idea to predict false sharing problem?
% What is the difference with Predator{}?
% For those predicted false sharing, we cannot predict performance improvement?



 