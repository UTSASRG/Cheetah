\begin{comment}
Multicore architectures 
cache system
sharing and false sharing
existing tools for false sharing
limitations
contributions
structures
\end{comment}

Multicore processors are ubiquitous in the whole computing spectrum, from mobile phones, personal desktops, to high-end servers. Multithreading is the de facto programming model to exploit the massive parallelism in modern architectures.
%Multithreading is widely used to employ these ubiquitous multicore processors for high parallelism. 
However, multithreaded programs may suffer from various performance bottlenecks because of complex memory hierarchies~\cite{ibs-sc,ibs-sc2,Dramon}, among which, false sharing is a common flaw that can significantly hurt the performance and scalability of multithreaded programs~\cite{falseshare:effect}. False sharing occurs when different threads, which are running on different cores with private caches, concurrently access logically independent words of the same cache line. When a thread modifies the data of a cache line, the cache coherence protocol (maintained by hardware) silently invalidates the duplicates of this cache line in the private caches of other cores~\cite{MESI}. Thus, even if other threads access independent words of this cache line, they have to unnecessarily reload the entire cache line from the shared cache or main memory. 

Unnecessary cache coherence caused by false sharing can dramatically degrade the performance of multithreaded programs by up to an order of magnitude~\cite{falseshare:effect}. A concrete example shown in Figure~\ref{fig:penalty} shows this catastrophic performance effect. We use multiple threads to accelerate the computation for the elements of {\tt array}. Given the false sharing in the accesses to {\tt array}, the execution does not scale at all. Moreover, the execution time slows down by up to $13\times$ slower (in red) than the ideal execution (in green) with no false sharing. The performance degradation caused by false sharing can be even more severe in modern architectures that integrate multiple sockets in chip; threads in different sockets involved in false sharing cause the cache coherence occurring in main memory not shared cache.
%As the hardware trend, including adding more cores into the same machine, introducing the Non-Uniform-Memory-Access (NUMA) architecture, or increasing the size of a cache line, will further degrade the performance of programs with false sharing.
%, making the task of detection even more urgent. 

\begin{figure*}[htbp]
\centering
\subfigure[A Program with False Sharing]{%
   \label{fig:penaltycode}
   \includegraphics[width=3.1in]{figure/fscode}

}%
\hspace{20pt}
\subfigure[Performance Degradation]{%
   \label{fig:penaltyfig}
   \includegraphics[width=3.1in]{figure/penalty}
}
\caption{
A false sharing example inside a multithreaded program (a) causes $13\times$ performance degradation (b) on a 8-core machine.
\label{fig:penalty}}
\end{figure*}

%\todo{Confirm the picture is readable in grey-style printing}

% Now we will talk about existing tools. 
Unlike true sharing, false sharing is generally avoidable. When threads unnecessarily share the same cache line, we can pad the data so that each thread can be forced to access a different cache line. Although the solution of fixing false sharing is somehow straightforward, detecting them is difficult and even impossible with manual checking, especially for a program with thousands or millions lines of code. Thus, it is very important to employ tools to pinpoint false sharing and provide insightful optimization guidance.

However, existing generic tools do not provide enough details about false sharing~\cite{gprof, ibs-sc, Intel:VTune}. Existing false sharing detection tools fall short in several ways. First, most tools do not distinguish true and false sharing, requiring substantial manual efforts to identify optimization opportunities~\cite{falseshare:binaryinstrumentation1,detect:ptu,detect:intel,falseshare:binaryinstrumentation2,DProf, qinzhao, OSdetection, mldetect, Wicaksono11detectingfalse, openmp}. Second, software-only tools~\cite{falseshare:binaryinstrumentation1,falseshare:binaryinstrumentation2,falseshare:simulator, Predator} introduce high runtime overhead, preventing them from uses in deployment environment. Third, OS-related tools have limitations, either with customized OS support~\cite{OSdetection}, or with special applications~\cite{Sheriff}. Fourth, to the best of our knowledge, no prior tool assesses the benefit from eliminating the false sharing. Without this information, many optimization efforts may yield trivial or no performance improvement.
In this paper, we present \cheetah{} to address these issues with the following contributions:
\begin{itemize} 

% The first one is overrated. We can't do that. 
\item {\bf First Approach to Predict False Sharing Impact.} This paper introduces the first approach to predict the performance impact of fixing false sharing instances for multithreaded programs. Based on our evaluation, \cheetah{} can precisely assess the performance improvement, with less than 10\% difference. By ruling out trivial instances, we can avoid unnecessary manual efforts that lead to little speedups. 

\item {\bf An Efficient and Effective False Sharing Detection Tool.} \cheetah{} is designed as an efficient false sharing detector with $\sim$7\% runtime overhead, by utilizing the Performance Monitoring Units (PMU) that are available on modern CPU architectures. \cheetah{} can report precise information of false sharing problems, by pointing out the lines of code or the name of variables with problems. 
%which does not need custom OS,  or recompilation and changing of programs. 
\end{itemize}
\cheetah{} is language and compiler independent. It works on native binaries that are compiled with any optimization option. We evaluate \cheetah{} using two well-knwon benchmark suites, PARSEC~\cite{} and PHOENIX~\cite{}. \cheetah{} successfully identifies significant false sharing. Our experiments also show that the false sharing \cheetah{} does not report has negligible performance impact to the whole program.
%
%is very convenient to use, which is a library that can be preloaded (using \texttt{LD\_PRELOAD} or can be linked to: there is no need to change or recompile the programs, or to modify the underlying operating system.

The remainder of this paper is organized as follows. 
%Section~\ref{sec:overview} introduces the background of false sharing and the motivation of a new detection tool. 
Section~\ref{sec:detect} describes the design and implementation of false sharing detection tool. Section~\ref{sec:predictimprove} introduces how \cheetah{} assesses the performance impact of a false sharing instance. Section~\ref{sec:eval} presents experimental results, including effectiveness, performance overhead, and the precision of assessment. Section~\ref{sec:discuss} addresses main concerns on hardware dependence, performance and effectiveness. Section~\ref{sec:relatedwork} discusses related work and Section~\ref{sec:conclusion} concludes this paper. 



